<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Jinwoo's Portfolio</title>
    <!--Main CSS-->
    <link th:href="@{/assets/css/main.css}" rel="stylesheet">
</head>
<body class="dark-background">
    <main>

        <div class="main-menu">
            <div id="logo-btn" class="main-logo">
                Jinwoo Bak
            </div>
            <div class="main-menu-bar">
                <p>portFolio</p>
            </div>
            <div class="main-menu-bar">
                <p>aboutMe</p>
            </div>
        </div>

        <div class="main-text">

        </div>

        <div class="image-container">
            <ul>
                <li>
                    <div class="image-box" data-url="https://jinwoobak.duckdns.org:8081/doggimain">
                        <img th:src="@{assets/img/logo2.png}" alt="Image1">
                    </div>
                    <div class="item-title">Doggiverse</div>
                    <div class="item-description">
                        Servlet,JSP,JSTL을 사용해 전통적인 JAVA 기반 웹 애플리케이션을 개발했습니다.<br>
                        AJAX를 사용한 뉴스 크롤링과 게시판, 공공데이터포털의 유기동물데이터 API를 사용해 정보를 제공합니다.
                    </div>
                    <div class="tech-icons">
                        <div class="tech-icon">JAVA</div>
                        <div class="tech-icon">Servlet</div>
                        <div class="tech-icon">JSP</div>
                        <div class="tech-icon">Oracle</div>
                        <div class="tech-icon">Maven</div>
                    </div>
                </li>

                <!-- DoggiVerse -->
                <div id="popup1" class="popup">
                    <div class="popup-content">
                        <div class="popup-position">
                            <div class="popup-top">
                                <div class="code-button" data-popup="code-popup1">
                                    📋프로젝트 설명
                                </div>
                                <div class="code-button" data-popup="arch-popup1">
                                    💡SystemArch
                                </div>
                            </div>
                        </div>
                        <span id="close1" class="close">&times;</span>
                        <iframe id="popup-doggi" class="iframe" th:src="@{https://jinwoobak.duckdns.org:8081/doggimain}"></iframe>
                    </div>

                    <div id="code-popup1" class="code-popup">
                        <div class="code-popup-content">
                            <span class="code-close">&times;</span>
                            <h2>프로젝트 설명</h2>
                            <p>Servlet 및 JSP, JSTL, DAO로 서버사이드 렌더링을 하며 JDBC를 외부 네트워크로 연결하여 DB서버를 지속적으로 접속할 수 있게 시도한 프로젝트 입니다.</p>
                            <pre>
- Java를 기반으로한 MVC모델의 구조를 사용해 동적 웹 애플리케이션을 제작하게 되었습니다.

- Model은 DAO로 DB객체를 생성하고 View는 JSP,JSTL 요청과 호출을 하며, Controller는 Servlet으로 데이터 요청과 호출을 처리합니다.

- 집 컴퓨터에 DB서버를 구축하고 포트포워딩과 인바운드 규칙을 통해 공인 IP기반의 네트워크 Endpoint를 외부에서 원격 접속 가능하도록 시도했습니다.

- Create, Read, Update, Delete 기능을 분할하여 각각 별도로 동작하여 재사용이 가능한 설계를 만들고자 하였습니다.

- 공통 기능을 구분하여 생산성을 높일 수 있는 구조를 만들고자 했습니다.

- jQuery를 이용한 AJAX를 사용하여 비동기적으로 네이버 뉴스 ‘애견’에 관한 주제로 크롤링하여 데이터를 불러오는 방식으로 구현하였습니다.
</pre>

<p>&lt;좋았던 점&gt;<p>
<pre>
WAS와 JSP, Servlet에서 요청과 호출 처리시 흐름을 중점적으로 익히기 위해 노력했습니다. Web Container에서 Servlet, DAO로 이어져 데이터를 받아오는 방식이 흥미로웠고,
이를 이용한 게시판 서비스를 완성한 경험이 좋았습니다.

HTML문서를 클라이언트에게 반환하기 위해서 어떤 작업을 해야할지 고민했고, Web Crawling API와 AJAX 통신으로 HTML 문서를 파싱하고,
JSON으로 클라이언트에게 넘겨주는 작업을 직접 구현하여 웹 서비스의 동작 방식을 이해하는데 좋은 경험이 되었습니다.

기존에 알고있었던 네트워크 지식을 사용해 DB서버를 원격 접속시켜 팀원들의 편의성을 증대시킨 점이 좋았고,
이를 이용해서 웹 애플리케이션 배포도 수행해보면 좋지 않을까? 라는 생각을 했습니다.
</pre>
<p>&lt;아쉬운 점&gt;</p>
<pre>
DB에 대한 연결정보를 MyOracleConnection이라는 클래스 안에 하드 코딩된 상태로 넣어놓은 점이 아쉽습니다.
properties 파일로 민감 정보를 감춰야하는 로직을 구성해야 한다는 것을 고려하지 못했습니다.

테스트 코드에 대한 작성이 미흡했습니다. JUnit 라이브러리를 통해 servlet 동작 테스트를 수행하여 기능이 제대로 동작하는지 테스트 하는 부분이 많이 부족했다고 생각합니다.
</pre>

                        </div>
                    </div>
                </div>

                <div id="arch-popup1" class="code-popup">
                    <div class="code-popup-content">
                        <span class="code-close">&times;</span>
                        <h2>시스템 아키텍처</h2>
                        <p>Doggiverse 프로젝트 개발 시점</p>
                        <img th:src="@{assets/img/doggiverseArch.png}">
                    </div>
                </div>

                <li>
                    <div class="image-box" data-url="https://jinwoobak.duckdns.org:8447/semiprj">
                        <img th:src="@{assets/img/logo1.png}" alt="Image2">
                    </div>
                    <div class="item-title">StudyClub</div>
                    <div class="item-description">
                        Spring Framework를 기반으로 설계된 웹 애플리케이션 입니다.<br>
                        WebSocket 통신으로 WebRTC 1:1 화상채팅 기능을 구현했습니다.
                        TURN 서버를 구축하여 외부 연결에 대한 제약을 줄였습니다.
                        Mybatis를 통해 ORM스타일로 데이터를 처리합니다.
                        Spring의 요청 처리 과정을 익히고 활용하기 위해 프로젝트를 진행했습니다.
                    </div>
                    <div class="tech-icons">
                        <div class="tech-icon">Spring Framework</div>
                        <div class="tech-icon">JSP</div>
                        <div class="tech-icon">MySQL</div>
                        <div class="tech-icon">Maven</div>
                    </div>
                </li>

                <!-- StudyClub -->
                <div id="popup2" class="popup">
                    <div class="popup-content">
                        <div class="popup-position">
                            <div class="popup-top">
                                <div class="code-button" data-popup="code-popup2">
                                    📋프로젝트 설명
                                </div>
                                <div class="code-button" data-popup="arch-popup2">
                                    💡SystemArch
                                </div>
                            </div>
                        </div>
                        <span id="close2" class="close">&times;</span>
                        <iframe id="popup-study" class="iframe" th:src="@{https://jinwoobak.duckdns.org:8447/semiprj}"></iframe>
                    </div>

                    <div id="code-popup2" class="code-popup">
                        <div class="code-popup-content">
                            <span class="code-close">&times;</span>
                            <h2>프로젝트 설명 </h2>
                            <p>해당 프로젝트 페이지는 포트폴리오 배포를 위해 접근성을 위해 일부 기능이 빠져있습니다.</p>
                            <p>Spring Framework를 기반으로 설계되어 WebRTC API를 이용한 화상채팅 기능을 구축하고, WAS를 Self-Hosted 배포 하여 외부에서 서비스를 이용하도록 시도해본 프로젝트입니다.</p>
                            <pre>
- Spring의 servlet-context를 활용한 bean 생성과 어노테이션을 이용한 의존성 주입으로 객체간 결합을 느슨하게 하기 위해 노력했습니다.

- DispatcherServlet -> Handler매핑 -> Handler어댑터 -> Controller -> ViewResolver 순서의 요청 처리 과정을 기반으로 프로젝트를 진행했습니다.

- WebSocket의 afterConnection과 handler를 제어해보면서 handshake로 소켓 세션을 생성하고 이를 WebRTC에 적용하기 위해 시도해 보았습니다.

- MyBatis를 활용하여 SQLmapper를 사용한 DB 연동을 구성하여 기존의 하드 코딩된 SQL문에서 벗어나 유연한 빌드 작업을 시도하였습니다.

- WAS에 SSL 보안인증을 설정하고 https 프로토콜 연결을 시도했습니다. 보안을 위해 http 접속시 https 주소로 자동 리다이렉트되는 설계를 하였습니다.

- WAS를 집 컴퓨터를 활용해 외부 접속이 가능하도록 호스팅 배포를 시도했습니다. DDNS를 활용하여 접속 주소를 만들어 활용하였습니다.
                            </pre>
                            <h3>구현 기능</h3>
                            <p>Chat</p>
                            <pre>
WebRTC를 구현하기 앞서 WebSocket을 이용해서 실시간 채팅 기능을 구현해보았습니다.
클라이언트가 HTTP Handshake 요청시 Spring에서는 HandshakeHandler가 요청을 처리하고 WAS에서 TCP 연결을 승인하여 소켓을 통한 양방향 통신이 설정됩니다.
이때 WebSocketSession 객체를 통해 클라이언트와 연결된 세션을 관리하고 HandleTextMessage로 클라이언트가 입력한 텍스트를 전송시킵니다.
                            </pre>
                            <p>StudyRoom</p>
                            <pre>
게시판과 비슷하게 텍스트 채팅과 1:1 화상채팅을 제어할 수 있도록 방을 구성했습니다. 고유 RoomId에 따라 같은 방에 있는 접속자들 끼리 연결할 수 있도록 하였습니다.
또한 세션의 유저 아이디를 가져와 서로가 식별할 수 있게 만들었습니다.
                            </pre>
                            <p>WebRTC - Peer to Peer 미디어 스트림</p>
                            <pre>
Signaling Server : 클라이언트에 의해 PeerConnection이 생성되면 WebSocket을 통해 SDP Offer로 세션 정보를 상대방에게 보내고,
NAT환경을 통과시켜 공인IP를 받아올 STUN서버를 거쳐 ICE Candidate(통신식별 후보자)가 등록되고 다른 클라이언트도 같은 방식으로 시그널링 서버에서 연결하고 데이터를 교환하게 됩니다.
                            </pre>
                            <p>Self-Hosted Deployment</p>
                            <pre>
WAS를 집 컴퓨터를 이용해 외부 접속이 가능하도록 호스팅 배포를 하고싶었습니다.
Tomcat SSL을 등록하여 Https연결을 활성화 시키고 이전에 DB서버 원격접속과 마찬가지로 WAS접속 포트를 인바운드 규칙에 설정하고
WebRTC 시그널링 서버로 이용되기에 아웃바운드 규칙도 같이 설정해주고 라우터에서 포트포워딩을 하여 외부에서 접속이 가능하도록 만들었습니다.
                            </pre>
                            <br>
                            <img th:src="@{assets/img/sc1.png}">
                            <img th:src="@{assets/img/sc2.png}"><br>
                            <p>TURN 서버 구축</p>
                            <pre>
배포 된 프로젝트가 NAT 환경에 있기 때문에 다른 환경(공용wifi, LTE)에서 접근이 불가능한 문제가 있어 google에서 제공한 STUN 서버로는 한계가 있었습니다.
시그널링 서버로 접근하기 위해서 TURN 서버를 구축하여 다양한 환경에서 연결하도록 설정하였습니다. 해당 TURN 서버는 리눅스에서 COTURN을 이용하여 구축하였습니다.
                            </pre>

                        </div>
                    </div>
                </div>

                <div id="arch-popup2" class="code-popup">
                    <div class="code-popup-content">
                        <span class="code-close">&times;</span>
                        <h2>시스템 아키텍처</h2>
                        <p>StudyClub 프로젝트 개발 시점 (현재 turn 서버 추가)</p>
                        <img th:src="@{assets/img/studyArch.png}">
                    </div>
                </div>

                <li>
                    <div class="image-box" data-url="https://jinwoobak.duckdns.org:8091">
                        <img th:src="@{assets/img/logo3.png}" alt="Image3">
                    </div>
                    <div class="item-title">Tetrapod</div>
                    <div class="item-description">
                        Spring Boot를 기반으로 설계된 웹 애플리케이션 입니다.<br>
                        마이크로서비스 환경에서 과도한 트래픽의 분산처리에 대해 고민하고 이를 해결하는 방법에 대한 생각에서 출발한 프로젝트입니다.
                        해당 프로젝트는 Kafka의 데이터 이동과정을 시각화하는 View를 제공합니다.
                        작은 게시판으로 DB에 직접 등록하는 것과 Kafka Connect를 활용하여 Topic을 거쳐 DB로 저장되는 과정을 보여줍니다.
                    </div>
                    <div class="tech-icons">
                        <div class="tech-icon">Spring Boot</div>
                        <div class="tech-icon">HTML/CSS/JS</div>
                        <div class="tech-icon">Thymeleaf</div>
                        <div class="tech-icon">MySQL</div>
                        <div class="tech-icon">JPA</div>
                        <div class="tech-icon">Gradle</div>
                        <div class="tech-icon">Kafka</div>
                    </div>
                </li>

                <!-- Tetrapod -->
                <div id="popup3" class="popup">
                    <div class="popup-content">
                        <div class="popup-position">
                            <div class="popup-top">
                                <div class="code-button" data-popup="code-popup3">
                                    📋프로젝트 설명
                                </div>
                                <div class="code-button" data-popup="arch-popup3">
                                    💡SystemArch
                                </div>
                            </div>
                        </div>
                        <span id="close3" class="close">&times;</span>
                        <iframe id="popup-tetra" class="iframe" th:src="@{https://jinwoobak.duckdns.org:8091}"></iframe>
                    </div>

                    <div id="code-popup3" class="code-popup">
                        <div class="code-popup-content">
                            <span id="code-close3" class="code-close">&times;</span>
                            <h2>프로젝트 설명</h2>
                            <p>마이크로 서비스 환경에서 과도한 트래픽의 분산처리에 대해 고민해보고 이를 해결하는 방법에 대해 모의해보는 생각에서 시작한 프로젝트 입니다.</p>
                            <pre>
- Spring Boot를 사용하여 프로젝트를 진행했습니다. application.properties 파일로 DB나 JPA 설정을 제어하고 Gradle로 빌드작업을 수행했습니다.

- 처음 구상한 것은 DB Replication으로 읽기 작업이 월등히 많다는 것을 생각하여 쓰기는 MasterDB에 읽기는 Slave로 부하분산처리를 시도하였습니다.

- DB에 접근시 매번 새로운 연결을 거치는 것에서 탈피하여 DBCP로 미리 여러개의 Pool을 생성하여 자원관리와 접근 속도를 증가시켰습니다.

- 부하 분산을 위해 DB Sharding에 대해 고민해보고 테이블 수평 분할시 PK가 꼬이는 문제를 해결하기 위해 Snowflake를 사용해보았습니다.

- Caffeine Cache를 사용하여 자주 참조되는 데이터를 캐시에 저장하고 읽기에 대한 부하를 낮추기 위해 고민했습니다.

- Kafka를 사용하여 Broker라는 서버 노드를 생성하여 Topic의 파티션에 데이터를 저장하여 DB에 접근하지 않고 데이터 교환을 하는 방식을 고민했습니다.

- 해당 프로젝트는 MySQL을 이용했습니다. 이유는 Kafka Connect용 JDBC에 많은 비용을 지불해야하기 때문입니다.
                        </pre>
                            <h3>구현 기능</h3>
                            <p>DB Replication</p>
                            <pre>
클라이언트가 요청시 내부에서는 DispatcherServlet을 거쳐 Handler가 호출되고 요청한 트랜젝션에 따라 분기점이 나누어집니다.
클래스에 상속된 AbstractRoutingDataSource에 따라 CUD는 Master로 R은 Slave로 라우팅되어 DataSource가 결정되고
Hikari Connection Pool에 연결되어 해당 DataSource에 접근하여 DB작업이 수행됩니다. DB 내부에서는 CUD작업시 Slave와 BackupDB에 복제하여 데이터 관리를 수행합니다.
                            </pre>
                            <img th:src="@{assets/img/dbms.png}">
                            <img th:src="@{assets/img/datasource.png}">

                            <p>Caffeine Cache</p>
                            <pre>
읽기에 대한 부하를 최대한 줄이기 위해서 캐시 처리를 시도했습니다. enum으로 설정 값을 정의해 만료시간과 캐시크기를 설정하였습니다.
Caffeine Cache는 다른 캐시 라이브러리들 보다 매우 빠른 속도를 가졌으며 캐시 관리 기능을 제공하기에 채택했습니다.
                            </pre>

                            <p>Snowflake</p>
                            <pre>
- 더 높은 성능을 위해 수평적 확장인 DB Sharding에 대해 고민했습니다. 기존 DB Replication에서 데이터를 여러 노드로 나누어 요청하는 클라이언트를 더욱 분산하는 목적에서 고려했습니다.

- 설계시 PK가 충돌하거나, 특정 Shard에만 데이터가 쏠리면 DB복제나, 백업에 더 많은 자원을 써야하는 안전하지 못한 문제 때문에 도입하게 되었습니다.
Snowflake는 twitter(현재 X)의 분산 컴퓨팅 환경에서 사용되는 64bit 정수형 고유 식별자로 타임스탬프와 노드식별ID, 밀리초당 일련 번호를 조합하여 채번을 생성합니다.
그렇기 때문에 샤딩시 PK가 충돌 될 일이 없고 join이나 정렬도 가능하여 사용하게 되었습니다.
                            </pre>

                            <p>Kafka</p>
                            <pre>
- DB Replication은 Apache Jmeter에 10초간 10만번의 요청을 기준으로 테스트 한 결과 만족스럽지 못한 성능을 보여줬습니다. 이에 대한 대안으로 Kafka에 대해 알게되어 적용해보았습니다.

- Kafka가 작동하려면 크게 3가지로 데이터를 전송하는 Producer, 이를 소비하는 Consumer, 둘을 중계하는 Broker로 구성됩니다.
먼저 Broker를 관리하기 위해 Zookeeper를 실행하고 Kafka Server를 실행하여야합니다. 이를 Spring에서 제어하기 위해 ZookeeperHandler와 KafkaHandler를 통해 실행하고
properties파일에서 Group-id와 Topic을 생성합니다. Group은 작업에 따라 어떤 Topic에 접근하는지 구분하는 역할을 합니다.

- 메시지를 전송하기 위해 Entity를 정의해주고 Producer와 Consumer가 Topic의 메시지를 받기위해 BoardProducer 클래스에서 보낼 메시지를 양식에 맞게 구성하고
Producer Factory에서는 메시지를 전송 가능한 바이트 배열로 변환시키는 직렬화를 수행하고 Consumer Factory에서는 역직렬화를 통해 json형태의 메시지로 받게됩니다.
                            </pre>

                            <p>Kafka Connect</p>
                            <pre>
- 전송 받은 메시지를 DB에 저장하여 데이터를 관리하고 동기화하기 위해 사용하였습니다.

- Source Connect : DB테이블에 Insert시 Topic으로 전송하는 역할을 합니다. json 설정파일을 이용하여 Connect Topic을 생성하고 Kafka MySQL Connect를 사용해 DB와 Kafka를 동기화 시킵니다.

- Sink Connect : Topic으로 메시지가 도착하면 DB테이블에 Insert 하는 역할을 합니다. Payload라는 포맷에 맞춰 DB가 받는 형식으로 변환하여 Insert 시킵니다.
                            </pre>
                            <p>Source Connector</p><br>
                            <img th:src="@{assets/img/sourceConnector.gif}">
                            <p>Sink Connector</p><br>
                            <img th:src="@{assets/img/sinkConnector.gif}"><br>
                            <p>FlowChart</p><br>
                            <img th:src="@{assets/img/mermaid.png}">
                        </div>
                    </div>
                </div>

                <div id="arch-popup3" class="code-popup">
                    <div class="code-popup-content">
                        <span class="code-close">&times;</span>
                        <h2>시스템 아키텍처</h2>
                        <p>Tetrapod 프로젝트 개발 시점</p>
                        <img th:src="@{assets/img/tetraArch.png}">
                    </div>
                </div>

                <li>
                    <div class="image-box" data-url="https://jinwoobak.duckdns.org:8090/">
                        <img th:src="@{assets/img/logo4.png}" alt="Image4">
                    </div>
                    <div class="item-title">PortForge</div>
                    <div class="item-description">
                        리눅스를 기반으로한 프로젝트 포트폴리오 배포 프로젝트입니다.<br>
                        AWS Cloudfront와 S3 Bucket으로 정적인 페이지를 배포하고 프로젝트 항목은 리눅스 서버에 링크됩니다.
                    </div>
                    <div class="tech-icons">
                        <div class="tech-icon">RockyLinux</div>
                        <div class="tech-icon">HTML/CSS/JS</div>
                        <div class="tech-icon">XRDP</div>
                    </div>
                </li>

                <!-- PortForge -->
                <div id="popup4" class="popup">
                    <div class="popup-content">
                        <div class="popup-position">
                            <div class="popup-top">
                                <div class="code-button" data-popup="code-popup4">
                                    📋프로젝트 설명
                                </div>
                                <div class="code-button" data-popup="arch-popup4">
                                    💡SystemArch
                                </div>
                            </div>
                        </div>
                        <span id="close4" class="close">&times;</span>
                        <iframe id="popup-portForge" class="iframe" th:src="@{https://jinwoobak.duckdns.org:8090/}"></iframe>
                    </div>

                    <div id="code-popup4" class="code-popup">
                        <div class="code-popup-content">
                            <span class="code-close">&times;</span>
                            <h2>프로젝트 설명</h2>
                            <p>Linux에 대해 공부하고, 이를 이용하여 개발 환경을 구축하여 프로젝트를 배포하기 위한 프로젝트 입니다.</p>
                            <pre>
- 모든 portfolio 프로젝트를 외부에 접근 가능한 형태로 배포하고자 하는 목적에서 기획하였습니다.

- 기존의 Self-hosting 방식과 Cloud Service를 결합하여 Hybrid Cloud와 비슷한 환경으로 만들어 보고자 하였습니다.

- AWS를 이용하여 Route53에서 접속 도메인 주소를 받고 S3와 Cloud Front를 통해서 정적인 페이지를 배포합니다.

- Back-end 서비스는 집에서 구성한 Linux 기반의 서버를 구축하여 사용하였습니다.

- Docker를 통해 컨테이너를 만들고 이를 Tomcat으로 구동하여 동적인 페이지를 배포합니다.

- AWS - CloudFront에서 portfolio 항목당 링크를 Linux로 배포된 페이지로 링크하여 각각 개별로 동작하는 페이지로 구성하였습니다.

- Tomcat, JAVA, MySQL, Intellij, Postman, Kafka, XRDP, GNOME을 설치하여 개발 환경을 구성했습니다.
                        </pre>
                            <h3>개요</h3>
                            <p>XRDP</p>
                            <pre>
- XRDP를 사용하여 리눅스 노트북의 불편한 입력 도구에서 벗어나 윈도우 PC에서 원격접속하여 조금 더 편하게 개발할 수 있게 시도했습니다.

    $ sudo yum install epel-release
    $ sudo yum install xrdp
    $ sudo systemctl start xrdp
    # 시스템 시작 시 xrdp 서비스 자동으로 시작하게 하고자 할 경우
    $ sudo systemctl enable xrdp

    vi /etc/xrdp/xrdp.ini
    port=3389 #원하는 포트로 설정
    systemctl restart xrdp
    netstat -nltp | grep xrdp

    sudo firewall-cmd --permanent --add-service=xrdp
    sudo firewall-cmd --permanent --add-port=설정한포트번호/tcp
    sudo firewall-cmd --reload

    엔드포인트에서 포트포워딩하여 연결
                            </pre>
                            <img th:src="@{assets/img/xrdp.png}">
                            <img th:src="@{assets/img/xrdp2.png}">
                            <p>Let's Encrypt</p>
                            <pre>
- HTTPS 연결을 위한 SSL 발급을 위해 사용하였습니다. 해당 인증서는 StudyClub 프로젝트와 AWS + 리눅스 서버 배포시 보안과 일관성을 위해 사용되었습니다.

  sudo yum install epel-release
  sudo yum install certbot
  sudo certbot certonly --standalone -d 도메인 -> !에러발생

  설치는 성공했으나 DDNS로 배포하려고 시도했으나, iptime DDNS는 인증서 정책을 선언,확인하기 위한 CAA레코드가 제거되어 인증서 발급이 불가능 하다.
  DDNS를 CAA레코드가 설정되어있는 다른 도메인으로 등록하여 해결하였다.


 openssl로 개인키를 PKCS12 형식으로 변환합니다.

 openssl pkcs12 -export -in /etc/letsencrypt/live/domain/fullchain.pem
-inkey /etc/letsencrypt/live/domain/privkey.pem
-out /etc/letsencrypt/live/domain/keystore.p12
  &lt;Connector
          protocol="org.apache.coyote.http11.Http11NioProtocol"
          port="8447"
          maxThreads="200"
          scheme="https"
          secure="true"
          SSLEnabled="true"
          keystoreFile="/etc/letsencrypt/live/domain/keystore.p12"
          keystorePass="your_keystore_password"
          clientAuth="false"
          sslProtocol="TLS"&gt;

  tomcat에서 server.xml에서 해당 p12파일을 등록하면 인증서 연결이 정상적으로 완료됩니다.
                            </pre>
                            <img th:src="@{assets/img/cert.png}">
                            <img th:src="@{assets/img/cert1.png}">
                        </div>
                    </div>
                </div>

                <div id="arch-popup4" class="code-popup">
                    <div class="code-popup-content">
                        <span class="code-close">&times;</span>
                        <h2>시스템 아키텍처</h2>
                        <p>PortForge 프로젝트</p>
                        <img th:src="@{assets/img/portforgeArch.png}">
                    </div>
                </div>
            </ul>
        </div>

    </main>
<script type="text/javascript" th:src="@{/assets/js/main.js}"></script>
</body>
</html>